## 工厂模式

工厂模式是为了把初始化对象的逻辑从具体业务代码中分离出来，做到业务代码和初始化对象的松耦合。

### 简单工厂模式

简单工厂模式就是声明一个工厂类，将初始化对象的逻辑放在这个工厂类里。
简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，
对于客户端来说，去除了与具体产品的依赖。

这样每新增一个对象类型，就要在这个工厂类里新增初始化逻辑，违反了开放封闭原则。
策略模式文件下的normal包就用了简单工厂模式。

### 工厂方法模式

工厂方法模式，定义一个用于创建对象的接口，让子类或实现类决定实例化那一个类。
工厂方法使一个类的实例化延迟到其子类或实现类。

工厂方法模式实现时，客户端需要决定实例化哪一个工厂类来执行具体的实例化。
选择判断问题还是存在的，也就是说工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。
你想要加功能，简单工厂中是修改工厂类，工厂方法中是修改客户端。

### 抽象工厂模式

抽象工厂模式提供了一个创建一系列相关或相互依赖的对象的接口，而无需指定它们具体的类。
一个抽象工厂接口，它里面应该包含所有的产品创建的抽象方法。
具体的工厂实现抽象工厂接口，这个具体的工厂在创建具有特定实现的产品对象，也就是说为创建不同的产品对象，客户端应使用不同的具体工厂。

抽象工厂模式的优点：

1. 易于交换产品系列。由于具体工厂类在一个应用中只需要在初始化的时候出现一次，
这就使得改变一个应用的具体工厂变得非常容易，只需要改变具体工厂即可使用不同的产品配置。

2. 抽象工厂让具体的创建实例过程与客户端分离，客户端是通过他们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端中。

抽象工厂模式缺点：

每增加一个产品，就要添加对应的产品接口和具体的实现类。概要更改抽象工厂类和具体的工厂实现类。

### 简单工厂改进抽象工厂

用简单工厂代替抽象工厂中抽象工厂接口以及其实现类，
这样客户端就只有简单工厂类，并且之后扩展的时候只需要更改简单工厂类，不需要更改客户端，达到了和客户端解耦的目的。

在简单工厂改进抽象工厂的基础上，添加反射机制，通过配置文件读入需要实例化的类，
这样扩展的时候简单工厂类也不用更改，只需要更改配置和添加响应的产品实现类就可以了。
