##代理模式

使用代理模式创建代表对象(representative)，让代表对象控制某对象的访问。
被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。

你是一个白脸，提供很好且很友善的服务，但是你不希望每个人都叫你做事，所以你找了黑脸控制对你的访问。
这就是代理要做的：控制和管理访问。

代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，
这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。

静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），
非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，
并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。

从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。

###代理模式和装饰者模式

代理模式和装饰者模式在代码实现上很相似，但是它们的出发点和意图是不一样的。
装饰者模式是为了给对象增加额外的功能，我认为主要是旧代码已存在，为了不破坏旧代码并增加新功能，装饰者模式应运而生。
代理模式则是为了控制外界对对象的访问，增加权限控制和打印日志等。
装饰者模式可能会有好多层，形成一个装饰者链。而代理模式通常只有一层。

装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已。
代理模式强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。
代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。

装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案。
代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。

装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。

代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。
代理模式的目的是，当直接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。
本体定义了关键功能，而代理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。
装饰者模式的作用就是为对象动态加入行为。
换句话说，代理模式强调一种关系(Proxy和它的实体之间的关系)，这种关系可以静态的表达，也就是说，这种关系在一开始就可以被确定。
而装饰者模式用于一开始不能确定对象的全部功能时。
代理模式通常只有一层代理-本体的引用，而装饰者模式经常会形成一条长长的装饰链。