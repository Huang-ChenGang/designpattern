使用代理模式创建代表对象(representative)，让代表对象控制某对象的访问。
被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。

你是一个白脸，提供很好且很友善的服务，但是你不希望每个人都叫你做事，所以你找了黑脸控制对你的访问。
这就是代理要做的：控制和管理访问。

代理模式是一种比较好理解的设计模式。简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，
这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。

静态代理中，我们对目标对象的每个方法的增强都是手动完成的，
非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。
实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，
并且也不需要我们必须实现接口，我们可以直接代理实现类。
从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

Java里动态代理主要分为两种：JDK动态代理和CGLIB动态代理

JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。
另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。